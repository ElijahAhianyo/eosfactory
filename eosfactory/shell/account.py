import sys
import json
import inspect
import traceback
import time
import re
import importlib

import eosfactory.core.logger as logger
import eosfactory.core.config as config
import eosfactory.core.setup as setup
import eosfactory.core.errors as errors
import eosfactory.core.interface as interface
import eosfactory.core.teos as teos
import eosfactory.core.interface as interface
BASE_COMMANDS = importlib.import_module(".base", setup.interface_package())
GET_COMMANDS = importlib.import_module(".get", setup.interface_package())
SET_COMMANDS = importlib.import_module(".set", setup.interface_package())
SYS_COMMANDS = importlib.import_module(".sys", setup.interface_package())
import eosfactory.core.manager as manager
import eosfactory.core.testnet as testnet_module
import eosfactory.core.account as account_module
import eosfactory.shell.wallet as wallet


IS_MASTER_ACCOUNT = "is_master_account"
IS_ACCOUNT = "is_account"


def set_is_master_account(account_object):
    setattr(account_object, IS_MASTER_ACCOUNT, True)


def set_is_account(account_object):
    setattr(account_object, IS_ACCOUNT, True)


def add_methods_and_put_on_stack(account_object_name, account_object, stack=None):
    # """Ascribes methodes to the given ``account_object``, and finalizes the creation 
    # of this ``account_object``.
    # """

    account_object.account_object_name = account_object_name
    
    class GetAccountAccount(account_object.__class__, Account):
        pass
    account_object.__class__ = GetAccountAccount
    set_is_account(account_object)

    wallet.Wallet.wallet_singleton.map_account(account_object)
    # export the account object to the globals in the wallet module:
    if not stack:
        stack = wallet.Wallet.wallet_globals
    stack[account_object_name] = account_object

    logger.TRACE("""
        * Cross-checked: account object ``{}`` mapped to an existing 
            account ``{}``.
        """.format(account_object_name, account_object.name), translate=False)


class Account():
    """Methods to be ascribed to account objects.
    """
    def stop_if_account_is_not_created(self):
        if not hasattr(self, IS_ACCOUNT):
            raise errors.Error("""
            The Account-class object is not set.
            Use 'create_account' factory function to set it.
            """)

    def stop_if_account_is_eosio(self):
        if self.name == "eosio":
            raise errors.Error("""
            Cannot do this with the ``eosio`` account.
            """)

    def actions(self, pos=None, offset=None, console=False):
        """Retrieve all actions with the account name referenced in authorization or receiver.

        Note that available actions are filtered. By default, all actions are
        filered off. To see the actions, the node has to be restarted with the --filter-on option.

        Args:
            pos (int): Sequence number of action for this account, -1 for last. 
                Default is -1.
            offset (int): Get actions [pos,pos+offset] for positive offset or 
                [pos-offset,pos) for negative offset. Default is 1.
            console (bool): print console output generated by action. Default 
                is ``False``.
        """
        self.stop_if_account_is_not_created()

        try:
            self.actions_result = GET_COMMANDS.GetActions(
                                self, pos, offset, console, is_verbose=False)
        except errors.UserError as ex:
            manager.user_error(ex)

        logger.INFO("""
        * actions()
        """)
        logger.OUT(str(self.actions_result))

    def code(self, code=None, abi=None, wasm=True):
        """Retrieve the code and ABI

        Args:
            code (str): If set, the name of the file to save the contract 
                WASM to.
            abi (str): If set, the name of the file to save the contract ABI to.
            wasm (bool): Save contract as wasm.
        """
        self.stop_if_account_is_not_created()

        try:
            self.code_result = GET_COMMANDS.GetCode(
                                    self, code, abi, wasm, is_verbose=False)
        except errors.UserError as ex:
            manager.user_error(ex)
            
        logger.INFO("""
        * code()
        """)
        logger.OUT(str(self.code_result))

    def is_code(self):
        """Determine whether any contract is set to the account.

        Return:
            True if the retrieved hash code of the contract code is not null.    
        """
        self.stop_if_account_is_not_created()
        get_code = GET_COMMANDS.GetCode(self.name, is_verbose=False)
        if get_code.code_hash == "0" * 64:
            return ""
        else:
            return get_code.code_hash

    def set_contract(
            self, contract_dir, 
            wasm_file="", abi_file="",
            clear=False, 
            permission=None, expiration_sec=None, 
            skip_sign=0, dont_broadcast=0, force_unique=0,
            max_cpu_usage=0, max_net_usage=0,
            ref_block=None,
            delay_sec=0
        ):
        """Create or update the contract.

        Call ``EOSIO cleos`` with the ``set contract`` command. Store the result,
        which is an object of the class :class:`.cleos.set.SetContract`, as
        the value of the ``set_contract`` attribute.

        Args:
            contract_dir (str): A path to a directory.
            wasm_file (str): The WASM file relative to the contract_dir.
            abi_file (str): The ABI file for the contract, relative to the
                contract-dir.
            clear (bool): Remove contract on an account. Default is False.

        See definitions of the remaining parameters: \
        :func:`.cleos.base.common_parameters`.
        """
        self.stop_if_account_is_not_created()

        try:
            self.contract_result = SET_COMMANDS.SetContract(
                        self, contract_dir, 
                        wasm_file, abi_file,
                        clear, 
                        permission, expiration_sec, 
                        skip_sign, dont_broadcast, force_unique,
                        max_cpu_usage, max_net_usage,
                        ref_block,
                        delay_sec,
                        is_verbose=False
                    )
        except errors.UserError as ex:
            manager.user_error(ex)
            
        logger.OUT(self.contract_result)

    def set_account_permission(
                self, 
                permission_name=None, 
                authority=None, 
                parent=None,
                permission=None,
                add_code=False,
                remove_code=False,
                expiration_sec=None, 
                skip_sign=0, dont_broadcast=0, return_packed=0, force_unique=0,
                max_cpu_usage=0, max_net_usage=0,
                ref_block=None,
                delay_sec=0
        ):
        """Set parameters dealing with account permissions.

        Call ``EOSIO cleos`` with the ``set account permission`` command. Store
        the result, which is an object of the 
        class :class:`.cleos.set.SetAccountPermission`, as the value of the ``account_permission`` attribute.

        Args:
            permission_name (str or .Permission): The permission to set/delete
                an authority for (defaults to: "active").
            parent (str or .Permission): The permission name of
                this parents permission (defaults to: "active").
            authority (str or dict or filename):  Public key, JSON string or
            filename defining the authority. ``NULL`` or "REMOVE" or "delete" 
                (case insensitive) to delete.
            add_code (bool): If set, add 'eosio.code' permission to specified
                permission authority. Default is false.
            remove_code (bool): If set, remove 'eosio.code' permission from
                specified permission authority. Default is false.

        See definitions of the remaining parameters: \
        :func:`.cleos.base.common_parameters`.

        NOTE::

            `cleos` eosio CLI demands that the lists in the `authority` JSON
            are specifically sorted. EOSFactory sorts them itself.
        """
        self.stop_if_account_is_not_created()
        logger.TRACE("""
            * Set account permission.
            """)

        try:
            self.account_permission_result \
                = SET_COMMANDS.SetAccountPermission(
                    self, permission_name, authority, parent,
                    permission,
                    add_code,
                    remove_code,
                    expiration_sec, 
                    skip_sign, dont_broadcast, return_packed, force_unique,
                    max_cpu_usage, max_net_usage,
                    ref_block,
                    delay_sec,
                    is_verbose=False
                )
        except errors.UserError as ex:
            manager.user_error(ex)

        logger.INFO("""
            * account permission ``{}``:
            """.format(authority))
    
    def set_action_permission(
                self, code, type, requirement,
                permission=None,
                expiration_sec=None, 
                skip_sign=0, dont_broadcast=0, return_packed=0, force_unique=0,
                max_cpu_usage=0, max_net_usage=0,
                ref_block=None,
                delay_sec=0
        ):
        """Set parameters dealing with account permissions.

        Call ``EOSIO cleos`` with the ``set action permission`` command. Store
        the result, which is an object of the
        class :class:`.cleos.set.SetActionPermission`, as the value of the
        ``action_permission`` attribute.

        Args:
            code (str or .interface.Account): The account that owns the code for \
                the action.
            type (str): The type of the action.
            requirement (str): The permission name require for executing the
            given action.

        See definitions of the remaining parameters: \
        :func:`.cleos.base.common_parameters`.
        """
        self.stop_if_account_is_not_created()
        logger.TRACE("""
        * Set action permission.
        """)

        try:
            self.action_permission_result \
                = SET_COMMANDS.SetActionPermission(
                    self, code, type, requirement,
                    permission,
                    expiration_sec, 
                    skip_sign, dont_broadcast, return_packed, force_unique,
                    max_cpu_usage, max_net_usage,
                    ref_block,
                    delay_sec,
                    is_verbose=False
                )
        except errors.UserError as ex:
            manager.user_error(ex)

        logger.INFO("""
            * action permission ``{}``:
            """.format(type))

    def push_action(
            self, action, data="{}",
            permission=None, expiration_sec=None, 
            skip_sign=0, dont_broadcast=0, force_unique=0,
            max_cpu_usage=0, max_net_usage=0,
            ref_block=None, delay_sec=0):
        """Push a transaction with a single action.

        Call ``EOSIO cleos`` with the ``push action`` command. Store the result,
        which is an object of the class :class:`.cleos.base.PushAction`,  as
        the value of the ``action`` attribute.

        Args:
            action (str or json or filename): Definition of the action to 
                execute on the contract.
            data (str): The arguments to the contract, defaults to empty json.
            permission: defaults to self.

        See definitions of the remaining parameters: \
        :func:`.cleos.base.common_parameters`.

        Attributes:
            account_name (str): The EOSIO name of the contract's account.
            console (str): ``["processed"]["action_traces"][0]["console"]`` \
                component of EOSIO cleos responce.
            data (str): ``["processed"]["action_traces"][0]["act"]["data"]`` \
                component of EOSIO cleos responce.
        """
        self.stop_if_account_is_not_created()
        logger.TRACE("""
            * Push action.
            """)

        data = manager.data_json(data)
        permission = permission if permission else self

        try:
            self.action_result = BASE_COMMANDS.PushAction(
                self, action, data,
                permission, expiration_sec,
                skip_sign, dont_broadcast, force_unique,
                max_cpu_usage, max_net_usage,
                ref_block,
                is_verbose=False)
        except errors.UserError as ex:
            manager.user_error(ex)

        logger.INFO("""
            * push action ``{}``:
            """.format(action))

        logger.INFO("""
            {}
        """.format(re.sub(' +',' ', data)))
        if self.action_result.console:
            logger.DEBUG(self.action_result.console)

    def show_action(
            self, action, data, permission=None,
            expiration_sec=None, 
            skip_sign=0, force_unique=0,
            max_cpu_usage=0, max_net_usage=0,
            ref_block=None, delay_sec=0
            ):
        """ Implement the `push action` command without broadcasting. 
        """
        self.stop_if_account_is_not_created()

        try:
            self.push_action(
                action, data,
                permission, expiration_sec, 
                skip_sign, dont_broadcast=1, force_unique=force_unique,
                max_cpu_usage=max_cpu_usage, max_net_usage=max_net_usage,
                ref_block=ref_block, delay_sec=delay_sec)
        except errors.UserError as ex:
            manager.user_error(ex)

    def table(
            self, table_name, scope="", 
            binary=False, 
            limit=10, lower="", upper="", index="",
            key_type="", encode_type="", reverse=False, show_payer=False
            ):
        """Retrieve the contents of a database table

        Args:
            table (str): The name of the table as specified by the contract abi.        
            scope (str or .interface.Account): The scope within the account in 
                which the table is found.
            binary (bool): Return the value as BINARY rather than using abi to 
                interpret as JSON. Default is ``False``.
            limit (int): The maximum number of rows to return. Default is 10.
            lower (str): JSON representation of lower bound value of key, 
                defaults to first.
            upper (str): JSON representation of upper bound value value of key, 
                defaults to last.
            index (int or str): Index number, 1 - primary (first), 2 - secondary 
                index (in order defined by multi_index), 3 - third index, etc.
                Number or name of index can be specified, 
                e.g. 'secondary' or '2'.
            key_type (str): The key type of --index, primary only supports 
                (i64), all others support (i64, i128, i256, float64, float128, 
                ripemd160, sha256).
                Special type 'name' indicates an account name.
            encode_type (str): The encoding type of key_type 
                (i64 , i128 , float64, float128) only support decimal 
                encoding e.g. 'dec'i256 - supports both 'dec' and 'hex', 
                ripemd160 and sha256 is 'hex' only.
            reverse (bool): Iterate in reverse order.
            show_payer (bool): Show RAM payer.

        Returns:
            (:class:`.cleos.get.GetTable`): object
        """
        self.stop_if_account_is_not_created()
        logger.INFO("""
        * Table ``{}`` for ``{}``
        """.format(table_name, scope))

        try:
            self.table_result = GET_COMMANDS.GetTable(
                        self, table_name, scope,
                        binary, 
                        limit, lower, upper, index, 
                        key_type, encode_type, reverse, show_payer,
                        is_verbose=False)
        except errors.UserError as ex:
            manager.user_error(ex)

        logger.OUT(str(self.table_result))
        return self.table_result

    def buy_ram(
            self, receiver=None,
            amount=None,
            ram_bytes=0,
            ram_kbytes=0,
            expiration_sec=None, 
            skip_sign=0, dont_broadcast=0, force_unique=0,
            max_cpu_usage=0, max_net_usage=0,
            ref_block=None):

        self.stop_if_account_is_not_created()
        if manager.is_local_testnet():
            logger.OUT("Testnet is local: buying rum function is disabled.")
            return

        receiver = receiver if receiver else self
        
        msg = "* buying ram from ``{}`` for ``{}``, ".format(
                                                interface.account_arg(self), 
                                                interface.account_arg(receiver))
        if amount:
            msg += "the amount is {}".format(amount)
        elif ram_bytes:
            msg += "the quantity is {} bytes".format(ram_bytes)
        elif ram_kbytes:
            msg += "the quantity is {} kbytes".format(ram_kbytes)
        logger.INFO(msg)

        try:
            self.buy_ram_result = SYS_COMMANDS.BuyRam(
                self, receiver,
                amount,
                ram_bytes,
                ram_kbytes,
                expiration_sec,
                skip_sign, dont_broadcast, force_unique,
                max_cpu_usage, max_net_usage,
                ref_block,
                is_verbose=0
                )
        except errors.UserError as ex:
            manager.user_error(ex)

    def delegate_bw(
            self,
            stake_net_quantity, stake_cpu_quantity,
            receiver=None,
            permission=None,
            transfer=False,
            expiration_sec=None, 
            skip_sign=0, dont_broadcast=0, force_unique=0,
            max_cpu_usage=0, max_net_usage=0,
            ref_block=None,
            is_verbose=1):

        self.stop_if_account_is_not_created()
        if manager.is_local_testnet():
            logger.OUT("Testnet is local: delegate bw function is disabled.")
            return

        receiver = receiver if receiver else self

        logger.INFO("""
        * Delegated stake from {} to {} NET: {} CPU: {}
        """.format(
            interface.account_arg(self), interface.account_arg(receiver),
            "%0.4f EOS" % (stake_net_quantity), 
            "%0.4f EOS" % (stake_cpu_quantity)))

        try:
            self.delegate_bw_result = SYS_COMMANDS.DelegateBw(
                self, receiver,
                stake_net_quantity, stake_cpu_quantity,
                permission,
                transfer,
                expiration_sec,
                skip_sign, dont_broadcast, force_unique,
                max_cpu_usage, max_net_usage,
                ref_block,
                is_verbose=0
                )
        except errors.UserError as ex:
            manager.user_error(ex)
            
    def info(self):
        self.stop_if_account_is_not_created()
        msg = manager.accout_names_2_object_names(
            "Account object name: {}\n{}".format(
            self.account_object_name,
            str(BASE_COMMANDS.GetAccount(
                                self.name, is_verbose=0))), True
        )
        # restore the physical account name
        msg = re.sub(r"(?<=^name: )\w+", self.name, msg, flags=re.M)
        msg = re.sub(r"(?<=^account_name: )\w+", self.name, msg, flags=re.M)
        print(msg)

    def stats(self, params, last_col="%s", col="%15s", to_string=False):
        def find(element, json):
            try:
                keys = element.split('.')
                rv = json
                for key in keys:
                    rv = rv[key]
            except:
                rv = "n/a"
            return rv

        json = BASE_COMMANDS.GetAccount(self, is_verbose=0).json
        json["account_object_name"] = self.account_object_name

        output = ""
        for param in params:
            output = output + col % find(param, json)
            output = output + "  " + last_col % (param) + "\n"
         
        if to_string:
            return output
        else:
            logger.OUT(output, translate=False)


    def __str__(self):
        self.stop_if_account_is_not_created()
        return self.name

    def __repr__(self):
        self.stop_if_account_is_not_created()
        return ""


def new_master_account(
            account_name=None, owner_key=None, active_key=None, testnet=None):
    """Create master account object in caller's global namespace.

    Wraps the account factory function :func:`create_master_account` so that
    the following statements are equivalent::

        MASTER = create_master_account("MASTER")
        MASTER = new_master_account()

    NOTE::

        With the `create_` syntax it is enough to state
        `create_master_account("MASTER")` in order to create the account
        object `MASTER`.

    Args:
        account_name (str or .core.testnet.Testnet): The name of an valid EOSIO
            account. Must be set if the testnode is not local.
        owner_key (str or .core.interface.Key): The owner public key. Must 
            be set if the testnode is not local.
        active_key (str or .core.interface.Key): The active public key. Must 
            be set if the testnode is not local.
        testnet (:class:`.core.testnet.Testnet`): If set, use is as the 
            definition of the account.
    """

    return create_master_account(
            get_new_account_name(inspect.getframeinfo(
                                            inspect.currentframe()).function), 
            account_name, owner_key, active_key, testnet)
        

def create_master_account(
            account_object_name, account_name=None, 
            owner_key_private=None, active_key_private=None, testnet=None):
    """Create master account object in caller's global namespace.

    Start a singleton :class:`.shell.wallet.Wallet` object, if it is not
    in the global namespace. Use this wallet object to keep private keys
    of any account to be created.

    If a local testnet is running, create an account object representing 
    ``eosio`` account. 
    
    Otherwise, an outer testnet has to be defined (with the function :func:`.core.setup.set_nodeos_address`). Then, if ``account_name`` is set, 
    check it for existence in the testnet. If it does not exist, raise an
    error if ``account_object_name`` is not ``None``, otherwise start the
    following registration procedure:

        - if the argument ``account_name`` is not set, make it random
        - loop:
            - print registration data, namely:
                - account name
                - owner public key
                - active public key
                - owner private key
                - active private key
            - wait for the user to register the account
            - . . .
            - check the newly registered account for existence in the testnet
            - DONE if the newly registered account exists in the testnet
    
    Finally, if the account object is successively defined then put it into the 
    global namespace.

    Note:: 
    
        If a new account object, named as an existing one, is going to be added 
        to the wallet, an error is reported. Then an offer is given to edith the 
        mapping file in order to resolve the conflict. When the conflict is 
        resolved, the procedure finishes successfully.

    Args:
        account_object_name (str): The name of the account object to be created.
        account_name (str or .core.testnet.Testnet): A valid EOSIO
            account. Must be set if the testnode is not local.
        owner_key_private (str): The owner private key. Must be
            set if the testnode is not local and the account not in the wallet.
        active_key_private (str): The active public key. Must be
            set if the testnode is not local and the account is not in the 
            wallet.
        testnet (:class:`.core.testnet.Testnet`): If set, use is as the 
            definition of the account.
    """

    if isinstance(account_name, testnet_module.Testnet):
        testnet = account_name

    if testnet:
        account_name = testnet.account_name
        owner_key_private = testnet.owner_key_private # Can be None
        active_key_private = testnet.active_key_private # Can be None    
        
    account_globals = create_wallet_if_none(inspect.stack()[1][0].f_globals)

    if account_object_name: # Not a ``register_testnet`` case:

        # When the wallet object is created, it can be restored from an existing
        # wallet file. Then the keys in the wallet are checked whether they
        # refer to accounts in the testnet. If such an account is found,
        # it is wrapped as an ``Account`` object and put into the global
        # namespace. 

        # Then, if the same object account is referred to by this object 
        # factory, it is simply returned.
        if is_in_globals(account_object_name, account_globals):
            logger.INFO("""
                ######## Account object ``{}`` restored from the blockchain.
                """.format(account_object_name)) 
            return account_globals[account_object_name]
    
        logger.INFO("""
            ######### Create a master account object ``{}``.
            """.format(account_object_name))

    """
    If a local testnet is running, create an account object representing 
    ``eosio`` account. 
    """
    if manager.is_local_testnet():
        account_object = account_module.Eosio(account_object_name)

        put_keys_to_wallet(account_object)
        set_is_master_account(account_object)
        add_methods_and_put_on_stack(account_object_name, account_object)

        logger.TRACE("""
            * The account ``{}`` is in the wallet.
            """.format(account_object.name))
        
        return account_object

    # If ``account_name`` is set then check the account name for existence and 
    # verify keys that possibly are set as ``owner_key_private`` and 
    # ``active_key_private`` or exist in the wallet.
    if account_name:
        account_object = account_module.GetAccount(
                                        account_object_name, account_name, 
                                        owner_key_private, active_key_private)
        if account_object.exists:
            # Verify the keys
            put_keys_to_wallet(
                account_name, 
                account_object.owner_key, account_object.active_key)

            if account_object_name:
                set_is_master_account(account_object)
                add_methods_and_put_on_stack(
                                        account_object_name, account_object)
            else:
                # The case of a call from the module ``eosfactory.register_testnet``
                pass

            return account_object
        
        elif account_object_name:
            # Not the case of a call from the module ``eosfactory.register_testnet``
            raise errors.Error("""
                There is no account named ``{}`` in blockchain {}.
                """.format(account_name, setup.nodeos_address()))
    
    # With a remote testnet, if ``account_name`` does not exist then it is to be
    # register there. Wait for a confirmation from the user then check it for 
    # existence.
    
    # With a remote testnet, if ``account_name`` is not set, randomize it and 
    # process it.

    while True:       
        account_name_new = account_name if account_name \
                                            else BASE_COMMANDS.account_name()
        owner_key_new = BASE_COMMANDS.CreateKey(is_verbose=False)
        active_key_new = BASE_COMMANDS.CreateKey(is_verbose=False)

        def msg(account_name_new):
            return """
Use the following data to register a new account with a public testnet:
    Account Name: {}
    Owner Public Key: {}
    Active Public Key: {}
""".format(
        account_name_new,
        owner_key_new.key_public,
        active_key_new.key_public
    )
        
        # Save the keys before the account is created. Otherwise, if the 
        # account exists in a blockchain and the computer system that has 
        # ordered creation fails, the account is lost. It is better to have 
        # an orphaned key in a wallet than to lose an account.
        put_keys_to_wallet(
                        account_name_new, owner_key_new, active_key_new)
        while True:
            is_ready = input(
                """{}
Enter 'go' when ready 
    or enter another name within quotation marks, for example "foo"
or 'q' to quit,  <<< """.format(msg(account_name_new)))
            if is_ready == "q":
                return
            elif is_ready[0] == '"' and is_ready[-1] == '"':
                account_name_new = is_ready.replace('"', "")
                print()
                continue
            elif is_ready == "go":
                break
            else:
                print()
                print("   Wrong answer!")
        
        account_name = account_name_new
        owner_key_private = owner_key_new.key_private
        active_key_private = active_key_new.key_private

        account_object = account_module.GetAccount(
                                        account_object_name, account_name, 
                                        owner_key_private, active_key_private)

        if account_object.exists:
            logger.TRACE("""
                * The account object is created.
                """)
            if account_object_name:
                set_is_master_account(account_object)
                add_methods_and_put_on_stack(
                                    account_object_name, account_object)
            else:
                # The case of a call from the module ``eosfactory.register_testnet``
                pass
            
            return account_object
        else:
            print()
            logger.OUT("#" * 100)
            logger.OUT("""
            The account '{}' does not exist in the testnet. Have you created on the testnet?
            Try again.
            """.format(account_name))


def restore_account(account_object_name, testnet_account):
    # """Create a restored account object in caller's global namespace.

    # Start a singleton :class:`.shell.wallet.Wallet` object if there is no one 
    # in the global namespace already.

    # If a local testnet is running, create an account object representing 
    # the ``eosio`` account. Put the account into the wallet. Put the account
    # object into the global namespace, and return.

    # Otherwise, an outer testnet has to be defined with the function
    # :func:`.core.setup.set_nodeos_address`.

    # Args:
    #     account_object_name (str): The name of the account object returned.
    #     testnet_account (.core.testnet.Testnet): A testnet object defining the account to restore.
    # """

    account_globals = create_wallet_if_none(inspect.stack()[1][0].f_globals)
           
    account_name = testnet_account.account_name

    if not testnet_account.url:
        eosio = create_master_account("eosio")
        create_account(account_object_name, eosio, account_name)
        return account_globals[account_object_name]

    if is_in_globals(account_object_name, account_globals):
        return account_globals[account_object_name]

    """
    Check the testnet for presence of the testnet account. If present, create 
    the corresponding object and see that it is in the wallets.
    """
    account_object = account_module.GetAccount(
        account_object_name, account_name,
        owner_key_private=testnet_account.owner_key_private,
        active_key_private=testnet_account.active_key_private)

    add_methods_and_put_on_stack(account_object_name, account_object)    
    
    logger.TRACE("""
        * The account object '{}' from testnet @ {} 
        is restored.
        """.format(account_name, testnet_account.url))

    return account_globals[account_object_name]


def new_account(
        creator, 
        account_name="",
        owner_key="", active_key="",
        stake_net=3, stake_cpu=3,
        permission=None,
        expiration_sec=None,
        skip_sign=0, dont_broadcast=0, force_unique=0,
        max_cpu_usage=0, max_net_usage=0,
        ref_block=None,
        delay_sec=0,        
        ram_kbytes=8, buy_ram="",
        transfer=False,
        restore=False):
    """Create account object in the global namespace.

    Wraps the account factory function :func:`create_account` so that the 
    following statements are equivalent::

        foo = create_account("foo", MASTER)
        foo = new_account(MASTER)

    NOTE::

        With the `create_` syntax it is enough to state 
        `create_account("foo", MASTER)` in order to create the account object
        `foo`.

    Args:
        creator (str or .core.interface.Account): The account creating the new 
            account
        account_name (str): The name of an valid EOSIO account. If not set, it 
            is random.
        owner_key (.core.interface.Key): The ``owner`` key pair. If not set, it
            is random.
        active_key (.core.interface.Key): The ``active`` key pair. If not set, 
            and the ``owner_key`` is set, it is substituted with the ``owner_key``.
            Otherwise, it is random.
        stake_net (int): The amount of EOS delegated for net bandwidth.
        stake_cpu (int): The amount of EOS delegated for CPU bandwidth.
        ram_kbytes (int): The amount of RAM bytes to purchase.
        transfer (bool): Transfer voting power and right to unstake EOS to 
            receiver.

    See definitions of the remaining parameters: \
    :func:`.cleos.base.common_parameters`.   
    """

    return create_account(
        get_new_account_name(inspect.getframeinfo(
            inspect.currentframe()).function), 
        creator, 
        account_name,
        owner_key, active_key,
        stake_net, stake_cpu,
        permission,
        expiration_sec,
        skip_sign, dont_broadcast, force_unique,
        max_cpu_usage, max_net_usage,
        ref_block,
        delay_sec,        
        ram_kbytes, buy_ram,
        transfer,
        restore)


def create_account(
        account_object_name,
        creator, 
        account_name="",
        owner_key=None, active_key=None,
        stake_net=3, stake_cpu=3,
        permission=None,
        expiration_sec=None,
        skip_sign=0, dont_broadcast=0, force_unique=0,
        max_cpu_usage=0, max_net_usage=0,
        ref_block=None,
        delay_sec=0,        
        ram_bytes=0, ram_kbytes=0, buy_ram="",
        transfer=False, testnet=None):
    """Create account object in the global namespace.

    Start a singleton :class:`.shell.wallet.Wallet` object, if it is not
    in the global namespace. Use this wallet object to keep private keys
    of any account to be created.

    Check it for existence in the testnet. If it is not set or it does not 
    exist, create it.

    Finally, if the account object is successively defined then put it into the 
    global namespace.

    Note:: 
    
        If a new account object, named as an existing one, is going to be added 
        to the wallet, an error is reported. Then an offer is given to edith the 
        mapping file in order to resolve the conflict. When the conflict is 
        resolved, the procedure finishes successfully.
    
    Args:
        account_object_name (str): The name of the account object returned.
        creator (str or .core.interface.Account): The account creating the new 
            account
        account_name (str): The name of an valid EOSIO account. If not set, it 
            is random.
        owner_key (.core.interface.Key): An owner's key. If not set, it 
            is randomized.
        active_key (.core.interface.Key): An active key. If not set, and the 
            ``owner_key`` is set, it is substituted with the ``owner_key``. 
            Otherwise, it is randomized.
        stake_net (int): The amount of EOS delegated for net bandwidth.
        stake_cpu (int): The amount of EOS delegated for CPU bandwidth.
        ram_bytes (int): The amount of RAM bytes to purchase.
        ram_kbytes (int): The amount of RAM kbytes to purchase.
        transfer (bool): Transfer voting power and right to unstake EOS to 
            receiver.
        testnet (:class:`.core.testnet.Testnet`): If set, use is as the 
            definition of the account.

    See definitions of the remaining parameters: \
    :func:`.cleos.base.common_parameters`.
    """
    try:
        if not owner_key:
            owner_key = interface.Key()
        else:
            if not isinstance(owner_key, interface.Key):
                raise errors.TypeError(
                            "owner_key", type(owner_key), type(interface.Key))
        if not active_key:
            active_key = active_key = owner_key
        else:
            if not isinstance(active_key, interface.Key):
                raise errors.TypeError(
                            "active_key", type(active_key), type(interface.Key))
    except errors.UserError as ex:
        manager.user_error(ex)

    if isinstance(account_name, testnet_module.Testnet):
        testnet = account_name

    if testnet:
        account_name = testnet.account_name
        owner_key.key_private = testnet.owner_key_private # Can be None
        active_key.key_private = testnet.active_key_private # Can be None 

    account_globals = create_wallet_if_none(inspect.stack()[1][0].f_globals)

    # When the wallet object is created, it can be restored from an existing
    # wallet file. Then the keys in the wallet are checked whether they
    # refer to accounts in the testnet. If such an account is found,
    # it is wrapped as an ``Account`` object and put into the global namespace. 

    # Then, if the same object account is referred to by this object factory, it
    # is simply returned.
    if is_in_globals(account_object_name, account_globals) \
                                and account_globals[account_object_name].name:
        logger.INFO("""
            ######## Account object ``{}`` restored from the blockchain.
            """.format(account_object_name))
        return account_globals[account_object_name]

    logger.INFO("""
        ######### Create an account object ``{}``.
        """.format(account_object_name))

    if not creator \
        or not (hasattr(creator, IS_ACCOUNT) \
                                    or hasattr(creator, IS_MASTER_ACCOUNT)):
            raise errors.Error("""
            The account creator is not set.
            Use 'create_master_account' factory function to set it.
            """)

    # If ``account_name`` is set then check the account name for existence and 
    # verify keys, set as ``owner_key_private`` and ``active_key_private``,
    # or existing in the wallet.
    if account_name:
        account_object = account_module.GetAccount(
                                        account_object_name, account_name, 
                                        owner_key.key_private, 
                                        active_key.key_private)
        if account_object.exists:
            # Verify the keys, raise an exception if verification fails.
            put_keys_to_wallet(account_object)

            set_is_master_account(account_object)
            add_methods_and_put_on_stack(account_object_name, account_object)
            
            return account_object

    if not account_name:
        account_name = BASE_COMMANDS.account_name()

    # Create a new account in the blockchain.
    if not (owner_key.is_complete() and active_key.is_complete()):
        owner_key = BASE_COMMANDS.CreateKey(is_verbose=False)
        active_key = BASE_COMMANDS.CreateKey(is_verbose=False)

    put_keys_to_wallet(account_name, owner_key, active_key)

    logger.INFO("""
                ... for a new blockchain account ``{}`` mapped as ``{}``.
                """.format(account_name, account_object_name))

    if manager.is_local_testnet():
        account_object = account_module.CreateAccount(
                creator, account_name,
                owner_key, active_key,
                permission,
                expiration_sec, skip_sign, dont_broadcast, force_unique,
                max_cpu_usage, max_net_usage,
                ref_block,
                delay_sec
                )
    else:
        try:
            account_object = account_module.SystemNewaccount(
                    creator, account_name, owner_key, active_key,
                    stake_net, stake_cpu,
                    permission,
                    ram_bytes, ram_kbytes, buy_ram,
                    transfer,
                    expiration_sec,
                    skip_sign, dont_broadcast, force_unique,
                    max_cpu_usage, max_net_usage,
                    ref_block,
                    delay_sec
                    )
        except errors.LowRamError as e:
            logger.TRACE("""
            * RAM needed is {}.kByte, buying RAM {}.kByte.
            """.format(
                e.needs_kbyte,
                e.deficiency_kbyte))

            ram_kbytes = str(e.deficiency_kbyte + 1)
            account_object = account_module.SystemNewaccount(
                    creator, account_name, owner_key, active_key,
                    stake_net, stake_cpu,
                    permission,
                    ram_bytes, ram_kbytes, buy_ram,
                    transfer,
                    expiration_sec, 
                    skip_sign, dont_broadcast, force_unique,
                    max_cpu_usage, max_net_usage,
                    ref_block,
                    delay_sec
                    )

    logger.TRACE("""
        * The account object is created.
        """)
    add_methods_and_put_on_stack(account_object_name, account_object)
    return account_object

def reboot():
    # """Reset the :mod:`.shell.account` module.
    # """
    if wallet.Wallet.wallet_singleton:
        wallet.Wallet.wallet_singleton.delete_globals()
        wallet.Wallet.wallet_singleton = None 

    wallet.Wallet.wallet_globals = None
    setup.reboot()


def create_wallet_if_none(account_globals):
    if not wallet.Wallet.wallet_singleton:
        wallet.create_wallet(wallet_globals=account_globals, restore=True)
    return wallet.Wallet.wallet_globals


def put_keys_to_wallet(account_object, owner_key=None, active_key=None):
    # """Make sure that the object keys are in a wallet.

    # If the keys of the given account are not in a wallet import them. Verify 
    # whether the imported private keys match their public counterparts.

    # Args:
    #     account_object (str or .interface.Account): The account that owns the
    #         keys.
    #     owner_key (.interface.Key): An owner key object, to be set if the
    #         ``object_account`` is referenced with its native account name.
    #     active_key (.interface.Key): An active key object, to be set if the
    #         ``object_account`` is referenced with its native account name.
    # """
    if account_object and not isinstance(account_object, str):
        owner_key = account_object.owner_key
        active_key = account_object.active_key

    if not active_key:
        active_key = owner_key

    logger.TRACE("""
        * Ensuring that the wallet has keys to the account ``{}``
        """.format(interface.Account(account_object).name))
    if not wallet.Wallet.wallet_singleton.keys_in_wallets(
                            [owner_key.key_public, active_key.key_public]):
        
        if not wallet.Wallet.wallet_singleton.import_key(owner_key) \
                                or not wallet.Wallet.wallet_singleton.import_key(active_key):
            raise errors.Error("""
            Wrong or missing keys for the account ``{}`` in the wallet.
            """.format(interface.Account(account_object).name))

        # See whether the imported private keys match their public counterparts.
        if not wallet.Wallet.wallet_singleton.keys_in_wallets(
                            [owner_key.key_public, active_key.key_public]):

            raise errors.Error("""
            Wrong or missing keys for the account ``{}`` in the wallet.
            """.format(interface.Account(account_object).name))


def print_stats(
        accounts, params, 
        last_col="%s", col="%15s"
    ):
    if manager.is_local_testnet():
        logger.OUT("Testnet is local: statistics function is disabled.")
        return

    def find(element, json):
        try:
            keys = element.split('.')
            rv = json
            for key in keys:
                rv = rv[key]
        except:
            rv = "n/a"
        return rv

    jsons = []
    for account in accounts:
        json = BASE_COMMANDS.GetAccount(account, is_verbose=0).json
        json["account_object_name"] = account.account_object_name
        jsons.append(json)

    header = ""
    for json in jsons:
        header = header + col % (json["account_object_name"])
    output = ".\n" + header + "\n"

    for param in params:
        for json in jsons:
            output = output + col % find(param, json)
        output = output + "  " + last_col % (param) + "\n" 

    logger.OUT(output, translate=False)
    

def is_in_globals(account_object_name, account_globals):
    if account_object_name in account_globals \
        and (hasattr(account_globals[account_object_name], IS_ACCOUNT) \
                or hasattr(account_globals[account_object_name], IS_MASTER_ACCOUNT)):
        return True
    return False


def get_new_account_name(function_name):
    frame = inspect.stack()[2][0]
    if not inspect.getmodule(frame):
        raise errors.Error("""
    'new_` account factory functions cannot be used interactively.
    Use 'create_' factory functions instead.
        """)
    frameinfo = inspect.getframeinfo(frame)
    lines = inspect.getsourcelines(inspect.getmodule(frame))

    count = 1
    while True:
        code = lines[0][frameinfo.lineno - count].strip()
        if function_name in code:
            break
        count = count + 1

    account_object_name = re.sub(r'\s*=\s*' + function_name + r'\(.*', "", code)
    account_object_name = re.sub(r'.*\.', "", account_object_name)
    if not function_name in code or not account_object_name.isidentifier():
        raise errors.Error("""
    Cannot determine the object name of a new account to be created.

    EOSFactory expects that {} factory function is used as in this example:
        foo = {}([creator], ...)
    where 
        'foo' variable assigned determines the name of the account object,
        'creator' variable refers to an account object that creates the new one.

    However, the relevant code line reads:
        {}
        """.format(function_name, function_name, code), translate=False)

    return account_object_name


